수학2
===========

## ✍수학2 목차
1. [a^b](#a^b)
2. [행렬](#행렬)
3. [피보나치수](#피보나치수)
4. [이항 계수](#이항-계수)
5. [카탈란 수](#카탈란-수)
6. [오일러 피함수](#오일러-피함수)
7. [나머지 연산2](#나머지-연산2)
<br>
<br>

### a^b
> a의 b제곱을 빠르게 구해야한다.

#### 시간복잡도 O(b)
```c++
int ans = 1;
for (int i = 1; i <= b; i++) {
	ans = ans * a;
}
```
> 더 빠른 방법을 이용해야한다.

#### 분할정복 ( O(logb) )
```c++
int calc(int a, int b) {
	if (b == 0) return 1; // a^0 = 1
	else if (b == 1) return a; // a^1 = 1
	else if (b % 2 == 0) { // a^b = a^b/2 * a^b/2 (b는 짝수)
		int tmp = calc(a, b / 2);
		return tmp * tmp;
	} 
	else { // a^b = a * a^(b-1) (b는 홀수) 
		return a * calc(a, b - 1);
	} 
}
```

#### 이진수 응용 ( O(logb) )
```c++
int calc(int a, int b) {
	int ans = 1;
	while (b > 0) {
		if (b % 2 == 1) {
			ans *= a;
		}
		a = a * a;
		b /= 2;
	}
	return ans;
}
```
- 동작 과정 (예시 a=3, b=27)
  1. 27은 이진수로 11011이다.
  2. 27=1+2+8+16
  3. 3^27=3^(1+2+8+16)
  

### 행렬
1. 행렬 덧셈
> 두 행렬을 입력받고 덧셈을 수행하는 문제.
```c++
for (int i = 0; i < n; i++) {
	for (int j = 0; j < m; j++) {
		c[i][j] = a[i][j] + b[i][j];
	}		
}
```

2. 행렬 곱셈
> 두 행렬을 입력받고 곱셈을 수행하는 문제.
```c++
/* a행렬 n*m, b행렬 m*k */
for (int i = 0; i < n; i++) {
	for (int j = 0; j < k; j++) {
		c[i][j] = 0;
		for (int h = 0; h < m; h++)
			c[i][j] += (a[i][h] * b[h][j]);
	}
}
```

3. 행렬 제곱
> 행렬을 입력받아 b번만큼 제곱을 수행하는 문제.
```c++
#include <iostream>
#include <vector>
using namespace std;

int n;
long long b;
vector<vector<int>> a;
vector<vector<int>> ans;

/*행렬의 곱셈*/
vector<vector<int>> cal(vector<vector<int>> &a, vector<vector<int>>& b) {
	int n = a.size();
	vector<vector<int>> c(n, vector<int>(n));

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < n; k++) {
				c[i][j] += a[i][k] * b[k][j];
			}
			c[i][j] %= 1000;
		}
	}
	return c;
}

int main() {
	cin >> n >> b;

	a.assign(n, vector<int>(n, 0));
	ans.assign(n, vector<int>(n, 0));

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> a[i][j];
		}
		ans[i][i] = 1;
	}

	/*이진수 응용*/
	while (b > 0) {
		if (b % 2 == 1) {
			ans =cal(ans, a);
		}
		a = cal(a, a);
		b /= 2;
	}

	for (int i = 0; i < ans.size(); i++) {
		for (int j = 0; j < ans[i].size(); j++) {
			cout << ans[i][j] << ' ';
		}
		cout << '\n';
	}

	return 0;
}
```

### 피보나치수
1. 피보나치 수
> N번째 피보나치 수를 구하는 문제 (N<=45)
```c++ 
/* DP를 이용한 피보나치 수열 */
#include <iostream>
#include <vector>
using namespace std;

int fibo[46];
int n;

int main() {
	cin >> n;
	fibo[0] = 0;
	fibo[1] = 1;

	for (int i = 2; i <= n; i++) {
		fibo[i] = fibo[i - 1] + fibo[i - 2];
	}
	cout << fibo[n];
}
```


2. 피보나치 수 2
> N번째 피보나치 수를 구하는 문제 (N<=90, int범위 초과)<br>
`위 코드에서 자료형만 long long 으로 고쳐준다.`

3. 피사노 주기
> 피보나치 수를 K로 나눈 나머지는 주기를 갖는다.
```c++
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
#define ll long long
vector<ll> fibo;
long long n;


int main() {
	int k = 0;
	int tmp = 1000000;

	while (tmp > 0) {
		k++;
		tmp /= 10;
	}

	ll cycle = 15 * pow(10, k - 1);

	fibo.resize(cycle);
	fibo[0] = 0;
	fibo[1] = 1;

	for (int i = 2; i < cycle; i++) {
		fibo[i] = fibo[i - 1] + fibo[i - 2];
		fibo[i] %= 1000000;
	}
	cin >> n;

	cout << fibo[n % cycle];
}
/*
	주기의 길이 K 
	N번째 피보나치 수를 M으로 나눈 나머지 = N%K 번째 피보나치 수
	M = 10^K, K > 2 이면, 주기는 항상 15*10^(K-1)이다.
*/
```

### 이항 계수
> n 개중 k개를 순서 없이 고르는 방법 nCk ( n!/k!(n-k)! )

#### 자연수 n,k가 주어질 때 nCk 구하기
```c++
#include <iostream>
#include <vector>
using namespace std;

int n, k;

int factorial(int num) {
	int ans = 1;

	for (int i = 1; i <= num; i++) {
		ans *= i;
	}
	return ans;
}
int main() {
	cin >> n >> k;

	cout << factorial(n) / (factorial(k) * factorial(n - k));
}
```

#### [파스칼의 삼각형](https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4%EC%B9%BC%EC%9D%98_%EC%82%BC%EA%B0%81%ED%98%95)
`파스칼의 삼각형을 이용한 이항 계수 구하기`
```c++
#include <iostream>
#include <vector>
using namespace std;

int n, k;
int dp[1001][1001];

int main() {
	cin >> n >> k;
	for (int i = 0; i <= n; i++) {
		dp[i][0] = dp[i][i] = 1;
		for (int j = 1; j <= i-1; j++) {
			dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % 10007;

		}
	}

	cout << dp[n][k] % 10007;
}
```
### 카탈란 수

### 오일러 피함수

### 나머지 연산2
