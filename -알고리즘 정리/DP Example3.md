DP Example3 LIS(최장 증가 부분수열)
===========

- 정의
> **수열 A의 부분 수열 중 증가 수열이 되는 가장 긴 부분수열**
<br>

- 풀이<br>
> 예시를 통해 풀이. A = {20, 1, 7, 4, 5, 6, 13, 3}  LIS(A) = {1, 4, 5, 6, 13} LIS의 길이=5
`D[i]`: i번째 원소를 마지막으로 갖는 최장 증가 수열의 길이<br>

### 조건
> 점화식은 코드에서 해당 조건을 만족하는 코드를 참고하기 바람.
1. A[i] 이전의 원소가 A[i]보다 작은 값을 가져야한다. ( A[j]<A[i] (j 0 to i-1) )
2. i번째 원소는 A[i]이다.

#### 예제 수열 A의 초기 상태
|idx|0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|A[i]|20|1|7|4|5|6|13|3|
|D[j]|0|0|0|0|0|0|0|0|

#### 예제 수열 A의 결과 (D[i]의 값중 가장 큰 값을 찾아야한다.)
|idx|0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|A[i]|20|1|7|4|5|6|13|3|
|D[j]|1|1|2|2|3|4|5|2|

### LCS Code
```c++
#include <iostream>
using namespace std;

int a[1000], d[1000];
// a : 원소 저장 , d : i번째 원소를 마지막으로 갖는 LIS의 길이
int main() {
    int n;
    cin >> n;

    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) { 
                // i번째 원소보다 작은 원소들 중
                if (d[i] < d[j]) {
                    d[i] = d[j];
                }
                // 최대 값
            }
        }
        d[i]++;
        // i번째 원소 포함
    }
    //조건을 만족하는 LIS의 값

    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (ans < d[i]) {
            ans = d[i];
        }
        // LIS 중 최대 값
    }

    cout << ans << "\n";
    return 0;
}

/*
input:
8
20  1  7  4  5  6  13  3

output(LIS의 길이):
5
*/
```
참고 사이트 : [코드그라운드 노트](https://www.codeground.org/common/popCodegroundNote)
