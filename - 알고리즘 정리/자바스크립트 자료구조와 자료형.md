코딩 테스트 대비 JavaScript
================
# 목차
   1. [객체](#객체)
      - 객체 선언 ,리터럴과 프로퍼티, 계산된 프로퍼티, 단축 프로퍼티, in연산자와 반복문, 객체 복사, 중첩 객체 복사, 생성자    
   2. [원시값의 메서드](#원시값의-메서드)

### 객체
- 객체 :
  - 프로퍼티에 다양한 종류의 값을 저장 할 수있다. key:문자형, value: 모든 자료형

1. 객체 선언 방법
```node
let user = new Object(); // 생성자 문법
let user = {}; // 리터럴 문법
```

2. 리터럴과 프로퍼티
```node
// 두개의 프로퍼티가 존재 (name,age)
let user = {
   name: "박",
   age: 28,
   "likes birds": true // 복수의 단어는 따옴표로 묶어야한다.
};

let key ="isAdmin";

user.isAdmin = true; 
user[key] = true;
user["isAdmin"] = true; // isAdmin 프로퍼티 추가
delete user.age; 
delete user[key]
delete user["age"] = // age 프로퍼티 삭제 

user.name = "김" // 상수 객체 수정 가능
```

3. 계산된 프로퍼티
   - 프로퍼티 키가 대괄호 [] 로 둘러싸여 있는 경우
```node
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
};
alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
```
```node
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {};

// 변수 fruit을 사용해 프로퍼티 이름을 만들었습니다.
bag[fruit] = 5;
```
   - 위 아래가 코드는 똑같은 동작을 한다.

4. 단축 프로퍼티
```node
function makeUser(name, age) {
  return {
    name, // name: name 과 같음
    age,  // age: age 와 같음
    // ...
  };
}
```

5. `in`연산자로 프로퍼티 존재 여부 확인 (find와 같음)
```node
// "key" in object

let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```

6. `for...in`반복문
```node
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
// 정수 key는 자동 정렬되고 , 나머지는 ㄱ들어온 순서대로

for (let key in user) {
  alert( key );  // name, age, isAdmin
  alert( user[key] ); // John, 30, true
}
```

7. 객체 복사
- 반복문 이용
```node
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

- assign 메서드 이용
```node
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
let clone = Object.assign({}, user); // 반복문 없이 전체 복사
```

8. 중첩 객체 복사
```node
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체입니다.

// user와 clone는 sizes를 공유합니다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경합니다.
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다.
```
9. 생성자 함수
```node
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```

[😊목차 가기](#목차)

### 원시값의 메서드
- 원시 값:
  - `문자(string)`, `숫자(number)`, `bingint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`

