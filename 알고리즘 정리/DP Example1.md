DP Example1 배낭 문제
===========

- 정의
> **무게 제한이 K인 배낭과 무게와 가치가 정해진 N개의 물건이 있을 때 가치의 총합이 가장 크도록 배낭을 싸는 문제**
<br>

- 조건<br>
1. 각 물건은 1개씩 존재하며 물건을 나누어 넣을수 없다 (ex) 7kg 물건을 3kg, 4kg으로 나누어 넣을 수 없다.)
2. 각 물건은 배낭에 넣거나, 넣지 않거나 둘 중 하나의 경우만 가진다.
3. 배낭에 넣은 물건 무게의 총합은 무게제한을 넘어서는 안된다.
<br>


- 풀이<br>
> V[N]: 물건의 가치, W[N]: 물건의 무게. D[N][K]: N개의 물건을 K무게 제한만큼 넣기<br>

점화식: **D[i][j] = Max(D[i-1][j], D[i-1][j - W[i]] + V[i])**<br>
* 위 D[i][j]를 채우는 두 가지 경우를 점화식으로 나타낸 것. 
  - D[i-1][j]는 i번째 물건을 넣지 않는 상태, 무게 j의 변화 없음.
  - D[i-1][j-W[i]] + V[i]는 i번째 물건을 넣는 상태를 의미, 무게 j에 물건의 무게 W[i]만큼 빼고, 가치 V[i]만큼 더해준다.

### 배낭 문제 Code
```c++
#include <iostream>
using namespace std;

int d[101][10001], v[101], w[101];
//d[i][j]= i번째 물건까지 (안)넣을 때 무게 j이하를 채우는 가치의 합 중 최대 값
// v[N] = 물건의 가치 , w[N] = 물건의 무게

int main() {
    int n, k;
    // 물건의 개수 n , 배낭의 무게 제한 k
    cin >> n >> k;

    for (int i = 1; i <= n; i++) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= k; j++) {
            if (j < w[i]) {
                d[i][j] = d[i - 1][j];
            } // 현재 넣을 물건의 무게가 남은 배낭의 무게 제한 보다 클 때 ( 물건을 안넣음 )
            else if (d[i - 1][j - w[i]] + v[i] > d[i - 1][j]) {
                d[i][j] = d[i - 1][j - w[i]] + v[i];
            } // 물건을 넣을 때의 가치가 안 넣을 때보다 더 클 때
            else {
                d[i][j] = d[i - 1][j];
            } // 물건을 안넣을 때의 가치가 넣을 때보다 더 클 때
        }
    }

    int ans = 0;
    for (int i = 0; i <= k; i++) {
        if (ans < d[n][i]) {
            ans = d[n][i];
        }
        // 최대 가치 구하기
    }

    cout << ans << "\n";
    return 0;
}
/*
input:
4  7 (물건 개수 N, 배낭의 무게제한 K)
13  6 (N개의 물건의 무게, 가치)
8  4
6  3
12  5
output(물건 가치의 총합):
14
*/
```
참고 사이트 : [코드그라운드 노트](https://www.codeground.org/common/popCodegroundNote)
