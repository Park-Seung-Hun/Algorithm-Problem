# 수학1

## ✍수학1 목차

1. [나머지와 연산](#나머지와-연산)
2. [최대공약수(GCD)](#최대공약수)
3. [최소공배수(LCM)](#최소공배수)
4. [진법 변환](#진법-변환)
5. [소수](#소수)
6. [소인수분해](#소인수분해)
7. [팩토리얼](#팩토리얼)
   <br>
   <br>

### 나머지와 연산

> 컴퓨터의 정수는 저장할 수 있는 범위 한계가 정해져있으므로, `답을 m으로 나눈 나머지를 출력하라는 문제`가 발생한다.<br>
> mod,% = 나머지 연산자

- (a + b) mod m=((a mod m) + (b mod m)) mod m
- (a _ b) mod m=((a mod m) _ (b mod m)) mod m
- (a - b) mod m=((a mod m) - (b mod m) + m) mod m
  - 나누기의 경우 성립하지 않는다. (Modular Inverse를 구해야 함.)
  - 뺄셈의 경우 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 m을 더해준다.
    <br>

[🚀목차로 가기](#수학1-목차)
<br>

### 최대공약수

> 줄여서, GCD로 불린다.<br>

- 두 수 A와 B의 최대공약수 G는 `A와 B의 공통된 약수 중 가장 큰 정수`이다.
- 최대공약수가 1인 두 수를 `서로소`라고 한다.

#### 최대공약수 구하는 방법1

- `2부터 min(A,B)까지 모든 정수로 나누어 보는 방법`

```c++
int g = 1;
for (int i = 2; i <= min(a, b); i++)
{
    if (a % i == 0 && b % i == 0)
        g = i;
}
}
```

#### 최대공약수 구하는 방법2

- `유클리드 호제법` 이용 (1번보다 더 빠르다.)
- a를 b로 나눈 나머지를 r이라고 할 때, `GCD(a,b) = GCD(b,r)` 이므로 `r이 0이면 그떄 b가 최대 공약수`이다.

```c++
// 재귀함수를 사용해서 구현
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

// 재귀함수를 사용하지 않고 구현
int gcd(int a,int b){
    while(b!=0){
        int r=a%b;
        a=b;
        b=r;
    }
    return a;
}
```

- 세 수의 GCD는 GCD(a,b,c)=GCD(GCD(a,b),c)와 같다.

[🚀목차로 가기](#수학1-목차)
<br>

### 최소공배수

> 줄여서, LCM로 불린다.<br>

- 두 수 A와 B의 최소공배수 G는 `A와 B의 공통된 배수 중 가장 작은 정수`이다.
- GCD를 응용해서 구할 수 있다.
- GCD(a,b)=g 일때 `최소공배수 l=g*(a/g)*(b/g)`

```c++
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int lcm(int a, int b)
{
    int g = gcd(a, b);
    return g * (a / g) * (b / g);
}
```

[🚀목차로 가기](#수학1-목차)
<br>

### 진법 변환

- 10진법 수 N을 B진법으로 바꾸려면 N이 0이될 때 까지 나머지를 계속해서 구해야한다.

#### 예시

> 11을 3진법으로 바꾸는 법

1. 11/3=3 , 나머지 2
2. 3/3=1 , 나머지 0
3. 1/3=0 , 나머지 1
4. 11은 3진법으로 `102`이다.

```c++
// 10진법 수 N을 B진법으로 바꿔 출력하는 문제 (2<=B<=36)
#include <iostream>
using namespace std;
char c[1001];

int main()
{
    long long N = 0;
    int B = 2;
    cin >> N >> B;
    int i = 1;
    while (N != 0)
    {
        c[i] = N % B + '0';
        if (N % B >= 10 && N % B <= 35)
        {
            c[i] = (N % B) + 55;
        }
        i++;
        N = N / B;
    }

    for (int j = i - 1; j >= 1; j--)
    {
        cout << c[j];
    }
}
/*
input:
60466175 36

output:
ZZZZZ
*/
```

[🚀목차로 가기](#수학1-목차)
<br>

### 소수

> 소수란? 약수가 1과 자기 자신 밖에 없는 수

- N이 소수가 되려면, `2보다 크거나 같고, 루트N 보다 작거나 같은 자연수`로 나누어 떨어지면 안된다.
  - N이 소수가 아니라면, N=a\*b로 나타낼 수 있다. (a<=b)
  - a > b라면 두 수를 바꿔서 항상 a<=b로 만들 수 있다.
  - 두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.

```c++
// 시간 복잡도 O(루트N)
bool prime(int n) {
	if (n < 2) {
		return false;
	}

	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}
```

#### 에라토스테네스의 체

> 1부터 N까지 모든 소수를 구하는데 걸리는 시간복잡도는 O(N루트N)이 걸리므로 긴 시간이 필요하다<br>
> 이를 해결하기 위한 방법으로 `에라토스테네스의 체`를 이용한다.

1. 2부터 N 까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 그 수의 배수를 모두 지운다.

```c++
int p[100]; // 소수 저장
int pn = 0; // 소수의 개수
bool c[101]; // 수가 지워졌으면 true
int n = 100; // 100까지 소수

for (int i = 2; i <= n; i++) {
	if (c[i] == false) {
		p[pn++] = i;

		for (int j = i * i; j <= n; j += i) {
			c[j] = true;
		}
	}
}
```

[🚀목차로 가기](#수학1-목차)
<br>

### 소인수분해

> 정수 N을 소수의 곱으로 분해 (소수를 구하지 않고도 해결 가능)

- N을 소인수분해 했을 때, 나타날 수 있는 인수 중에서 가장 큰 값은 루트N 이다.
- `2부터 루트 N까지 for문을 돌면서, N을 나눌 수 있으면, 나눌 수 없을 때 까지 계속해서 나눈다.`

```c++
for (int i = 2; i * i <= n; i++) {
	while (n % i == 0) {
		cout << i << '\n';
		n /= i;
	}
}
if (n > 1) {
	cout << n;
}
```

[🚀목차로 가기](#수학1-목차)
<br>

### 팩토리얼

> `N!=1*2*3*....*N`

#### 예제1) N!의 0의 개수

> 5의 개수를 세준다.

```c++
#include <iostream>
using namespace std;
int main() {
    int ans = 0;
    int n;
    cin >> n;
    for (int i=5; i<=n; i*=5) {
        ans += n/i;
    }
    cout << ans << '\n';
    return 0;
}
```

#### 예제2) 조합 nCm의 0의 개수

> 2,5의 개수를 세준다.

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
    long long two = 0, five = 0;
    long long n, m;
    cin >> n >> m;
    for (long long i=2; i<=n; i*=2) {
        two += n/i;
    }
    for (long long i=2; i<=n-m; i*=2) {
        two -= (n-m)/i;
    }
    for (long long i=2; i<=m; i*=2) {
        two -= m/i;
    }
    for (long long i=5; i<=n; i*=5) {
        five += n/i;
    }
    for (long long i=5; i<=n-m; i*=5) {
        five -= (n-m)/i;
    }
    for (long long i=5; i<=m; i*=5) {
        five -= m/i;
    }
    cout << min(two, five) << '\n';
    return 0;
}
```
