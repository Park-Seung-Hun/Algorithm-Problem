수학1
===========

## ✍수학1 목차
1. [나머지와 연산](#나머지와-연산)
2. [최대공약수(GCD)](#최대공약수)
3. [최소공배수(LCM)](#최소공배수)
4. [진법 변환](#진법-변환)
5. [소수](#소수)
6. [소인수분해](#소인수분해)
7. [팩토리얼](#팩토리얼)
<br>
<br>

### 나머지와 연산
> 컴퓨터의 정수는 저장할 수 있는 범위 한계가 정해져있으므로, `답을 m으로 나눈 나머지를 출력하라는 문제`가 발생한다.<br>
> mod,% = 나머지 연산자

- (a + b) mod m=((a mod m) + (b mod m)) mod m
- (a * b) mod m=((a mod m) * (b mod m)) mod m
- (a - b) mod m=((a mod m) - (b mod m) + m) mod m
  - 나누기의 경우 성립하지 않는다. (Modular Inverse를 구해야 함.)
  - 뺄셈의 경우 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 m을 더해준다.
  <br>

### 최대공약수
> 줄여서, GCD로 불린다.<br>
- 두 수 A와 B의 최대공약수 G는 `A와 B의 공통된 약수 중 가장 큰 정수`이다.
- 최대공약수가 1인 두 수를 `서로소`라고 한다.

#### 최대공약수 구하는 방법1
- `2부터 min(A,B)까지 모든 정수로 나누어 보는 방법`

```c++
int g = 1;
for (int i = 2; i <= min(a, b); i++)
{
    if (a % i == 0 && b % i == 0)
        g = i;
}
}
```

#### 최대공약수 구하는 방법2
- `유클리드 호제법` 이용 (1번보다 더 빠르다.)
- a를 b로 나눈 나머지를 r이라고 할 때, `GCD(a,b) = GCD(b,r)` 이므로 `r이 0이면 그떄 b가 최대 공약수`이다.

```c++
// 재귀함수를 사용해서 구현
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

// 재귀함수를 사용하지 않고 구현
int gcd(int a,int b){
    while(b!=0){
        int r=a%b;
        a=b;
        b=r;
    }
    return a;
}
```
- 세 수의 GCD는 GCD(a,b,c)=GCD(GCD(a,b),c)와 같다.

### 최소공배수
> 줄여서, LCM로 불린다.<br>
- 두 수 A와 B의 최소공배수 G는 `A와 B의 공통된 배수 중 가장 작은 정수`이다.
- GCD를 응용해서 구할 수 있다.
- GCD(a,b)=g 일때 `최소공배수 l=g*(a/g)*(b/g)`

```c++
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int lcm(int a, int b)
{
    int g = gcd(a, b);
    return g * (a / g) * (b / g);
}
```

### 진법 변환
- 10진법 수 N을 B진법으로 바꾸려면 N이 0이될 때 까지 나머지를 계속해서 구해야한다.

#### 예시
> 11을 3진법으로 바꾸는 법
1. 11/3=3 , 나머지 2
2. 3/3=1 , 나머지 0
3. 1/3=0 , 나머지 1
4. 11은 3진법으로 `102`이다.

```c++
// 10진법 수 N을 B진법으로 바꿔 출력하는 문제 (2<=B<=36)
#include <iostream>
using namespace std;
char c[1001];

int main()
{
    long long N = 0;
    int B = 2;
    cin >> N >> B;
    int i = 1;
    while (N != 0)
    {
        c[i] = N % B + '0';
        if (N % B >= 10 && N % B <= 35)
        {
            c[i] = (N % B) + 55;
        }
        i++;
        N = N / B;
    }

    for (int j = i - 1; j >= 1; j--)
    {
        cout << c[j];
    }
}
/*
input:
60466175 36

output:
ZZZZZ
*/
```

### 소수
> 소수란? 약수가 1과 자기 자신 밖에 없는 수
- N이 소수가 되려면, `2보다 크거나 같고, 루트N 보다 작거나 같은 자연수`로 나누어 떨어지면 안된다.
  - N이 소수가 아니라면, N=a*b로 나타낼 수 있다. (a<=b)
  - a > b라면 두 수를 바꿔서 항상 a<=b로 만들 수 있다.
  - 두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.
  
```c++
// 시간 복잡도 O(루트N)
bool prime(int n) {
	if (n < 2) {
		return false;
	}
	
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}
```

