# 소수

- N이 소수가 되려면, `2보다 크거나 같고, 루트N 보다 작거나 같은 자연수`로 나누어 떨어지면 안된다.
  - N이 소수가 아니라면, N=a*b로 나타낼 수 있다. (a<=b)
  - a > b라면 두 수를 바꿔서 항상 a<=b로 만들 수 있다.
  - 두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.

### 일반적인 방법

```c++
// 시간 복잡도 O(루트N)
bool prime(int n) {
	if (n < 2) {
		return false;
	}

	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}
```

### 에라토스테네스의 체

> 1부터 N까지 모든 소수를 구하는데 걸리는 시간복잡도는 O(N루트N)이 걸리므로 긴 시간이 필요하다<br>
> 이를 해결하기 위한 방법으로 `에라토스테네스의 체`를 이용한다.

1. 2부터 N 까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 그 수의 배수를 모두 지운다.

```c++
int p[100]; // 소수 저장
int pn = 0; // 소수의 개수
bool c[101]; // 수가 지워졌으면 true
int n = 100; // 100까지 소수

for (int i = 2; i <= n; i++) {
	if (c[i] == false) {
		p[pn++] = i;

		for (int j = i * i; j <= n; j += i) {
			c[j] = true;
		}
	}
}
```
