코딩 테스트 대비 JavaScript
================
# 목차
   1. [객체](#객체)
      - 객체 선언 ,리터럴과 프로퍼티, 계산된 프로퍼티, 단축 프로퍼티, in연산자와 반복문, 객체 복사, 중첩 객체 복사, 생성자    
   2. [원시값의 메서드](#원시값의-메서드)
      1. [숫자형](#숫자형) 
      2. [문자열](#문자열)

### 객체
- 객체 :
  - 프로퍼티에 다양한 종류의 값을 저장 할 수있다. key:문자형, value: 모든 자료형

1. 객체 선언 방법
```node
let user = new Object(); // 생성자 문법
let user = {}; // 리터럴 문법
```

2. 리터럴과 프로퍼티
```node
// 두개의 프로퍼티가 존재 (name,age)
let user = {
   name: "박",
   age: 28,
   "likes birds": true // 복수의 단어는 따옴표로 묶어야한다.
};

let key ="isAdmin";

user.isAdmin = true; 
user[key] = true;
user["isAdmin"] = true; // isAdmin 프로퍼티 추가
delete user.age; 
delete user[key]
delete user["age"] = // age 프로퍼티 삭제 

user.name = "김" // 상수 객체 수정 가능
```

3. 계산된 프로퍼티
   - 프로퍼티 키가 대괄호 [] 로 둘러싸여 있는 경우
```node
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
};
alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
```
```node
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {};

// 변수 fruit을 사용해 프로퍼티 이름을 만들었습니다.
bag[fruit] = 5;
```
   - 위 아래가 코드는 똑같은 동작을 한다.

4. 단축 프로퍼티
```node
function makeUser(name, age) {
  return {
    name, // name: name 과 같음
    age,  // age: age 와 같음
    // ...
  };
}
```

5. `in`연산자로 프로퍼티 존재 여부 확인 (find와 같음)
```node
// "key" in object

let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```

6. `for...in`반복문
```node
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
// 정수 key는 자동 정렬되고 , 나머지는 ㄱ들어온 순서대로

for (let key in user) {
  alert( key );  // name, age, isAdmin
  alert( user[key] ); // John, 30, true
}
```

7. 객체 복사
- 반복문 이용
```node
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

- assign 메서드 이용
```node
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
let clone = Object.assign({}, user); // 반복문 없이 전체 복사
```

8. 중첩 객체 복사
```node
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체입니다.

// user와 clone는 sizes를 공유합니다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경합니다.
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다.
```
9. 생성자 함수
```node
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
```

[😊목차 가기](#목차)

### 원시값의 메서드
- 원시 값:
  - `문자(string)`, `숫자(number)`, `bingint`, `불린(boolean)`, `심볼(symbol)`, `null`, `undefined`

##### 숫자형
1. 숫자의 다양한 표현
```node
let billion = 1000000000;
let billion = 1e9;  // 10억, 1과 9개의 0

let ms = 0.000001;
let ms = 1e-6; // 1에서 왼쪽으로 6번 소수점 이동

let Num;
Num = 0xff // 255 16진수
Num = 0b11111111; // 255의 2진수
Num = 0o377; // 255의 8진수

let num = 255; // nom.toString(base)

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

Math.floor(3.6) // 3 버림
Math.ceil(3.1) // 4 올림
Math.round(3.1) // 3 
Math.round(3.6) // 4 반올림
Math.trunc(3.1) // 3 소수부 무시

let sum=0.1+0.2; // 부정확한 계산
sum.toFixed(2) // "0.30" 문자열 반환.
+sum.toFixed(2) // 0.3 숫자 반환
```
2. isNaN과 isFinite

- inNaN(value): value를 숫자로 변환한 다음 NaN인지 테스트
```node
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
```
- isFinite(value): value를 숫자로 변환한 숫자가 일반 숫자인경우 true반환
```node
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, NaN이기 때문입니다.
alert( isFinite(Infinity) ); // false, Infinity이기 때문입니다.
```
3. parseInt와 parseFloat
   - 불가능할 때까지 문자열에서 숫자를 읽어 반환한다
```node
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.

lert( parseInt('a123') ); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지됩니다.

alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, 0x가 없어도 동작합니다.
alert( parseInt('2n9c', 36) ); // 123456
```
4. 기타 수학 함수

```node
Math.random() // 랜덤 수 반환 0~1사이
Math.max(a,b,c,....) // 최대
Math.min(a,b,c,....) // 최소
Math.pow(n.power) // n을 power번 거듭제곱
```


[😊목차 가기](#목차)

##### 문자열
1. 따옴표

```node
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

2. 문자열 프로퍼티
```node
let str="String"

str.length // 6 문자열 길이 반환
str[0] // 'S'
str.charAt(1) // 't'

for(let char of str){
   alert(char) // S t r i n g 차례로 출력
}
```

3. 문자열 불변성
   - 문자열은 수정 할 수 없다.
```node
let str = 'Hi';
str = 'h' + str[1]; // 문자열 전체를 교체함
// str[0] = 'T' 동작이 안됨
alert( str ); // hi
```

4. 대소문자 변경하기
```node
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

5. 부분 문자열 찾기
- `str.indexOf` 이용
   - str.indexOf(substr,pos) : str의 pos에서부터 시작해 substr의 위치를 반환하고, 존재하지 않을 시 -1 반환
   - str.lastIndexOf(substr, position) : str의 뒷부분에서 부분 문자열을 찾는다.
```node
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

- `includes`, `startsWith`, `endsWith`
   - str.includes(substr,pos) : 부분 문자열 존재 여부에 따라 true or false
   - str.startsWith(substr), str.endsWith(substr) : str이 특정 문자열로 시작하는지 여부와 특정 문자열로 끝나는지 여부를 확인
```node
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, 세 번째 위치 이후엔 "id"가 없습니다.

alert( "Widget".startsWith("Wid") ); // true, "Widget"은 "Wid"로 시작합니다.
alert( "Widget".endsWith("get") ); // true, "Widget"은 "get"으로 끝납니다.
```

6. 부분 문자열 추출하기
   - 부분 문자열 추출 메서드는 3가지이다.
   - `str.slice(start,end)`: start부터 end-1까지 문자열 반환 **가장 많이 사용**
   - `str.substring(start, end)`: start부터 end-1까지 문자열 반환 (start가 end보다 커도 괜찮다)
   - `str.subsrt(start, length)`: start부터 length만큼 문자열 반환
```node
let str = "stringify";

// 1.slice
alert( str.slice(0, 5) ); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 포함하지 않음)
alert( str.slice(2) ); // ringify, 2번째부터 끝까지
alert( str.slice(-4, -1) ); // gif

// 2. substring
// 동일한 부분 문자열을 반환합니다.
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// 3. substr
alert( str.substr(2, 4) ); // ring, 두 번째부터 글자 네 개
alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두 개
```

[😊목차 가기](#목차)
